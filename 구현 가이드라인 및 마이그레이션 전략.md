# 구현 가이드라인 및 마이그레이션 전략

이 문서에서는 Meta Cloud API 프로젝트에 트리 쉐이킹을 효과적으로 적용하기 위한 구체적인 구현 가이드라인과 마이그레이션 전략을 제시합니다. 기존 코드베이스를 점진적으로 개선하여 트리 쉐이킹이 가능한 구조로 변경하는 방법을 단계별로 설명합니다.

## 구현 접근 방식 선택

트리 쉐이킹을 적용하기 위한 세 가지 주요 접근 방식이 있습니다. 프로젝트의 규모와 복잡성, 그리고 팀의 리소스에 따라 적합한 접근 방식을 선택할 수 있습니다:

1. **점진적 개선 접근법**: 기존 구조를 유지하면서 barrel 파일의 export 방식만 변경
2. **모듈 구조 개선 접근법**: 경로 별칭과 명시적 export를 도입하여 모듈 구조 개선
3. **서브패키지 접근법**: 프로젝트를 여러 서브패키지로 분리하여 독립적인 모듈로 관리

각 접근 방식의 장단점을 비교하면 다음과 같습니다:

| 접근 방식 | 장점 | 단점 | 적합한 상황 |
|----------|------|------|------------|
| 점진적 개선 | - 구현이 간단함<br>- 기존 코드 변경 최소화<br>- 빠른 적용 가능 | - 트리 쉐이킹 효과 제한적<br>- 근본적인 구조 문제 해결 어려움 | - 빠른 개선이 필요한 경우<br>- 리소스가 제한적인 경우 |
| 모듈 구조 개선 | - 효과적인 트리 쉐이킹 가능<br>- 모듈 간 의존성 명확화<br>- 코드 유지보수성 향상 | - 기존 코드 변경 필요<br>- 사용자 코드 일부 수정 필요 | - 중간 규모 프로젝트<br>- 점진적 마이그레이션 가능한 경우 |
| 서브패키지 | - 최적의 트리 쉐이킹 효과<br>- 명확한 모듈 경계<br>- 독립적인 버전 관리 가능 | - 구현 복잡도 높음<br>- 대규모 코드 변경 필요<br>- 사용자 코드 수정 필요 | - 대규모 프로젝트<br>- 메이저 버전 업데이트 계획 시<br>- 충분한 리소스 확보 시 |

## 1. 점진적 개선 접근법 구현 가이드

### 1.1 barrel 파일 export 방식 변경

**단계 1: 타입 모듈 수정**

각 feature의 types/index.ts 파일을 수정하여 명시적 export 방식으로 변경합니다:

**변경 전:**
```typescript
// src/features/messages/types/index.ts
export * from './common';
export * from './contact';
// ...

export type { GeneralMessageBody, MessageRequestParams /* ... */ } from './common';
// ...
```

**변경 후:**
```typescript
// src/features/messages/types/index.ts
// 중복 export 제거, 명시적 export만 사용
export type { 
  GeneralMessageBody, 
  MessageRequestParams,
  MessagesClass, 
  MessagesResponse, 
  StatusParams 
} from './common';

export type { 
  TextMessageParams, 
  TextObject 
} from './text';

// 기타 필요한 타입들...
```

**단계 2: 기능 모듈 수정**

각 feature의 index.ts 파일을 수정하여 명시적 export 방식으로 변경합니다:

**변경 전:**
```typescript
// src/features/messages/index.ts
export * from './types';
export { default, default as MessagesApi } from './MessageApi';
export type {
    AudioMediaObject,
    ContactObject,
    // ...
} from './types';
```

**변경 후:**
```typescript
// src/features/messages/index.ts
import MessageApi from './MessageApi';

// 기본 export 유지
export default MessageApi;

// 명시적 named export
export { MessageApi };

// 필요한 타입만 명시적으로 export
export type {
    AudioMediaObject,
    ContactObject,
    DocumentMediaObject,
    // 기타 필요한 타입들...
} from './types';
```

**단계 3: 최상위 features/index.ts 수정**

features/index.ts 파일을 수정하여 명시적 export 방식으로 변경합니다:

**변경 전:**
```typescript
// src/features/index.ts
export * from './messages';
export * from './media';
// ...
```

**변경 후:**
```typescript
// src/features/index.ts
// Messages - 명시적 export
export { default as MessagesApi } from './messages';
export type {
    MessageRequestParams,
    MessagesResponse,
    // 필요한 타입들...
} from './messages';

// Media - 명시적 export
export { default as MediaApi } from './media';
// ...

// 다른 모듈들도 동일하게 명시적 export로 변경
```

**단계 4: 최상위 index.ts 수정**

src/index.ts 파일을 수정하여 명시적 export 방식으로 변경합니다:

**변경 전:**
```typescript
// src/index.ts
// Core exports
import { IRequest, IResponse, WebhookHandler } from './core/webhook';
import { WhatsApp } from './core/whatsapp';

// Default export
export default WhatsApp;

// Core exports
export { WebhookHandler, type IRequest, type IResponse };

// Feature exports
export * from './features';

// Shared exports
export * from './shared';
```

**변경 후:**
```typescript
// src/index.ts
// Core exports - 명시적 import 및 export
import { WebhookHandler } from './core/webhook';
import { WhatsApp } from './core/whatsapp';

// Default export
export default WhatsApp;

// Core exports - 명시적 export
export { WebhookHandler };
export type { IRequest, IResponse } from './core/webhook';

// Feature exports - 명시적 export
export { MessagesApi } from './features/messages';
export { MediaApi } from './features/media';
// 기타 필요한 API 클래스들...

// 필요한 타입들만 명시적으로 export
export type { MessageRequestParams, MessagesResponse } from './features/messages';
// 기타 필요한 타입들...

// Shared exports - 필요한 것만 명시적으로 export
export { HttpClient } from './shared/http';
export { formatUrl, parseResponse } from './shared/utils';
// 기타 필요한 유틸리티 함수들...
```

### 1.2 package.json 수정

package.json 파일에 sideEffects 필드를 추가하여 사이드 이펙트가 없음을 명시합니다:

```json
{
  "name": "meta-cloud-api",
  "version": "0.2.15",
  "sideEffects": false,
  // 기존 설정 유지
}
```

### 1.3 테스트 및 검증

변경 사항을 적용한 후 다음 단계로 테스트 및 검증을 수행합니다:

1. 기존 테스트 스위트 실행하여 기능 정상 작동 확인
2. 번들 크기 분석 도구를 사용하여 트리 쉐이킹 효과 측정
3. 샘플 애플리케이션에서 import 테스트 수행

## 2. 모듈 구조 개선 접근법 구현 가이드

### 2.1 경로 별칭 설정

**단계 1: tsconfig.json 수정**

tsconfig.json 파일에 경로 별칭을 추가합니다:

```json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"],
      "@features/*": ["src/features/*"],
      "@shared/*": ["src/shared/*"]
    },
    // 기존 설정 유지
  }
}
```

**단계 2: 빌드 도구 설정 수정**

tsup.config.ts 파일을 수정하여 경로 별칭을 지원하도록 설정합니다:

```typescript
import { defineConfig } from 'tsup';
import { resolve } from 'path';

export default defineConfig({
  entry: {
    index: 'src/index.ts',
  },
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  minify: true,
  splitting: true,
  treeshake: true,
  target: 'es2022',
  platform: 'node',
  external: ['node:*', 'crypto', 'fs', 'path', 'url', 'util'],
  esbuildOptions(options) {
    options.alias = {
      '@core': resolve(__dirname, 'src/core'),
      '@features': resolve(__dirname, 'src/features'),
      '@shared': resolve(__dirname, 'src/shared'),
    };
  },
});
```

### 2.2 모듈 간 import 수정

프로젝트 내 모든 파일의 import 문을 경로 별칭을 사용하도록 수정합니다:

**변경 전:**
```typescript
// src/features/messages/MessageApi.ts
import { HttpClient } from '@shared/http';
import { formatUrl } from '@shared/utils';
import { ApiConfig } from '@shared/types';
```

**변경 후:**
```typescript
// src/features/messages/MessageApi.ts
import { HttpClient } from '@shared/http';
import { formatUrl } from '@shared/utils';
import { ApiConfig } from '@shared/types';
```

### 2.3 다중 엔트리 포인트 설정

**단계 1: tsup.config.ts 수정**

tsup.config.ts 파일을 수정하여 다중 엔트리 포인트를 설정합니다:

```typescript
import { defineConfig } from 'tsup';
import { resolve } from 'path';

export default defineConfig({
  entry: {
    index: 'src/index.ts',
    core: 'src/core/index.ts',
    messages: 'src/features/messages/index.ts',
    media: 'src/features/media/index.ts',
    profile: 'src/features/profile/index.ts',
    // 각 기능별 엔트리 포인트 추가
  },
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  minify: true,
  splitting: true,
  treeshake: true,
  target: 'es2022',
  platform: 'node',
  external: ['node:*', 'crypto', 'fs', 'path', 'url', 'util'],
  esbuildOptions(options) {
    options.alias = {
      '@core': resolve(__dirname, 'src/core'),
      '@features': resolve(__dirname, 'src/features'),
      '@shared': resolve(__dirname, 'src/shared'),
    };
  },
});
```

**단계 2: package.json exports 필드 추가**

package.json 파일에 exports 필드를 추가하여 다중 엔트리 포인트를 설정합니다:

```json
{
  "name": "meta-cloud-api",
  "version": "0.2.15",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "default": "./dist/index.js"
    },
    "./core": {
      "types": "./dist/core.d.ts",
      "import": "./dist/core.js",
      "default": "./dist/core.js"
    },
    "./messages": {
      "types": "./dist/messages.d.ts",
      "import": "./dist/messages.js",
      "default": "./dist/messages.js"
    },
    "./media": {
      "types": "./dist/media.d.ts",
      "import": "./dist/media.js",
      "default": "./dist/media.js"
    },
    "./profile": {
      "types": "./dist/profile.d.ts",
      "import": "./dist/profile.js",
      "default": "./dist/profile.js"
    },
    // 각 기능별 export 추가
    "./package.json": "./package.json"
  }
}
```

### 2.4 테스트 및 검증

변경 사항을 적용한 후 다음 단계로 테스트 및 검증을 수행합니다:

1. 기존 테스트 스위트 실행하여 기능 정상 작동 확인
2. 번들 크기 분석 도구를 사용하여 트리 쉐이킹 효과 측정
3. 다양한 import 방식으로 테스트 수행:
   - 전체 패키지 import
   - 개별 모듈 import

## 3. 서브패키지 접근법 구현 가이드

### 3.1 프로젝트 구조 변경

**단계 1: 서브패키지 구조 생성**

다음과 같은 서브패키지 구조를 생성합니다:

```
meta-cloud-api/
├── packages/
│   ├── core/
│   │   ├── src/
│   │   │   ├── webhook/
│   │   │   ├── whatsapp/
│   │   │   └── index.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── messages/
│   │   ├── src/
│   │   │   ├── types/
│   │   │   ├── MessageApi.ts
│   │   │   └── index.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── media/
│   │   ├── src/
│   │   │   ├── types/
│   │   │   ├── MediaApi.ts
│   │   │   └── index.ts
│   │   ├── package.json
│   │   └── tsconfig.json
│   └── shared/
│       ├── src/
│       │   ├── http/
│       │   ├── types/
│       │   ├── utils/
│       │   └── index.ts
│       ├── package.json
│       └── tsconfig.json
├── package.json
└── tsconfig.json
```

**단계 2: 루트 package.json 설정**

루트 package.json 파일을 다음과 같이 설정합니다:

```json
{
  "name": "meta-cloud-api",
  "version": "0.2.15",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "build": "turbo run build",
    "test": "turbo run test",
    "lint": "turbo run lint",
    "clean": "turbo run clean"
  },
  "devDependencies": {
    "turbo": "^1.10.0",
    // 기존 devDependencies...
  }
}
```

**단계 3: 서브패키지 package.json 설정**

각 서브패키지의 package.json 파일을 다음과 같이 설정합니다 (예: core 패키지):

```json
{
  "name": "@meta-cloud-api/core",
  "version": "0.2.15",
  "description": "Core functionality for Meta's Cloud API",
  "type": "module",
  "main": "./dist/index.js",
  "types": "./dist/index.d.ts",
  "sideEffects": false,
  "scripts": {
    "build": "tsup --clean",
    "test": "vitest run",
    "lint": "eslint ."
  },
  "dependencies": {
    "@meta-cloud-api/shared": "0.2.15"
  },
  "publishConfig": {
    "access": "public"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/index.js",
      "default": "./dist/index.js"
    }
  }
}
```

**단계 4: 서브패키지 tsconfig.json 설정**

각 서브패키지의 tsconfig.json 파일을 다음과 같이 설정합니다:

```json
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src/**/*"]
}
```

### 3.2 코드 마이그레이션

**단계 1: 공유 모듈 마이그레이션**

shared 패키지를 먼저 마이그레이션합니다:

1. src/shared 디렉토리의 코드를 packages/shared/src로 복사
2. 필요한 타입과 유틸리티 함수를 명시적으로 export

**단계 2: 코어 모듈 마이그레이션**

core 패키지를 마이그레이션합니다:

1. src/core 디렉토리의 코드를 packages/core/src로 복사
2. shared 패키지에 대한 의존성 업데이트
3. 필요한 클래스와 타입을 명시적으로 export

**단계 3: 기능 모듈 마이그레이션**

각 기능 모듈을 개별 패키지로 마이그레이션합니다:

1. src/features/{feature} 디렉토리의 코드를 packages/{feature}/src로 복사
2. core 및 shared 패키지에 대한 의존성 업데이트
3. 필요한 클래스와 타입을 명시적으로 export

### 3.3 빌드 설정

**단계 1: Turborepo 설정**

루트 디렉토리에 turbo.json 파일을 생성하여 빌드 파이프라인을 설정합니다:

```json
{
  "$schema": "https://turbo.build/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "outputs": ["dist/**"]
    },
    "test": {
      "dependsOn": ["build"]
    },
    "lint": {},
    "clean": {
      "cache": false
    }
  }
}
```

**단계 2: 각 패키지의 tsup.config.ts 설정**

각 패키지의 tsup.config.ts 파일을 다음과 같이 설정합니다 (예: messages 패키지):

```typescript
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: {
    index: 'src/index.ts',
  },
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  minify: true,
  treeshake: true,
  target: 'es2022',
  platform: 'node',
  external: [
    '@meta-cloud-api/core',
    '@meta-cloud-api/shared',
    'node:*',
    'crypto',
    'fs',
    'path',
    'url',
    'util'
  ],
});
```

### 3.4 테스트 및 검증

변경 사항을 적용한 후 다음 단계로 테스트 및 검증을 수행합니다:

1. 각 패키지별 테스트 실행
2. 통합 테스트 실행
3. 번들 크기 분석
4. 샘플 애플리케이션에서 import 테스트 수행

## 마이그레이션 전략

### 점진적 마이그레이션 전략

대규모 변경을 한 번에 적용하기 어려운 경우, 다음과 같은 점진적 마이그레이션 전략을 사용할 수 있습니다:

1. **단계 1: 명시적 export 적용**
   - barrel 파일의 export 방식을 명시적 export로 변경
   - package.json에 sideEffects 필드 추가
   - 기존 API 호환성 유지

2. **단계 2: 다중 엔트리 포인트 도입**
   - tsup.config.ts에 다중 엔트리 포인트 설정
   - package.json에 exports 필드 추가
   - 새로운 import 방식 문서화 및 권장

3. **단계 3: 경로 별칭 도입**
   - tsconfig.json에 경로 별칭 설정
   - 내부 import 문 점진적 업데이트
   - 코드 품질 및 유지보수성 향상

4. **단계 4: 서브패키지 구조로 전환 (선택적)**
   - 메이저 버전 업데이트 시 서브패키지 구조 도입
   - 기존 API와의 호환성 계층 제공
   - 새로운 import 방식으로의 마이그레이션 가이드 제공

### 버전 관리 전략

트리 쉐이킹 개선을 위한 변경 사항을 적용할 때 다음과 같은 버전 관리 전략을 사용할 수 있습니다:

1. **마이너 버전 업데이트 (점진적 개선)**
   - 명시적 export 방식 변경
   - sideEffects 필드 추가
   - 기존 API 호환성 유지

2. **메이저 버전 업데이트 (구조적 변경)**
   - 다중 엔트리 포인트 도입
   - 서브패키지 구조로 전환
   - 새로운 import 방식 도입

### 사용자 마이그레이션 가이드

라이브러리 사용자를 위한 마이그레이션 가이드를 제공하여 새로운 import 방식으로의 전환을 돕습니다:

**변경 전 (barrel 파일을 통한 import):**
```typescript
import { WhatsApp, MessagesApi, MediaApi } from 'meta-cloud-api';
```

**변경 후 (다중 엔트리 포인트 사용):**
```typescript
import WhatsApp from 'meta-cloud-api';
import { MessagesApi } from 'meta-cloud-api/messages';
import { MediaApi } from 'meta-cloud-api/media';
```

**변경 후 (서브패키지 구조 사용):**
```typescript
import WhatsApp from '@meta-cloud-api/core';
import { MessagesApi } from '@meta-cloud-api/messages';
import { MediaApi } from '@meta-cloud-api/media';
```

## 성능 측정 및 모니터링

트리 쉐이킹 개선 효과를 측정하고 모니터링하기 위한 방법을 제시합니다:

### 번들 크기 분석

다음 도구를 사용하여 번들 크기를 분석하고 트리 쉐이킹 효과를 측정합니다:

1. **rollup-plugin-visualizer**: Rollup 번들의 시각적 분석 제공
2. **webpack-bundle-analyzer**: Webpack 번들의 시각적 분석 제공
3. **esbuild-visualizer**: esbuild 번들의 시각적 분석 제공

예시 설정 (rollup-plugin-visualizer):

```javascript
// rollup.config.js
import { visualizer } from 'rollup-plugin-visualizer';

export default {
  // 기존 설정...
  plugins: [
    // 기존 플러그인...
    visualizer({
      filename: 'bundle-analysis.html',
      open: true,
      gzipSize: true,
    }),
  ],
};
```

### 성능 벤치마킹

다음 지표를 사용하여 트리 쉐이킹 개선 효과를 측정합니다:

1. **번들 크기**: 최종 번들의 크기 (gzip 압축 전/후)
2. **로딩 시간**: 애플리케이션 초기 로딩 시간
3. **메모리 사용량**: 런타임 메모리 사용량

## 결론

이 문서에서는 Meta Cloud API 프로젝트에 트리 쉐이킹을 효과적으로 적용하기 위한 구체적인 구현 가이드라인과 마이그레이션 전략을 제시했습니다. 프로젝트의 규모와 복잡성, 그리고 팀의 리소스에 따라 적합한 접근 방식을 선택하여 트리 쉐이킹을 적용할 수 있습니다.

점진적 개선 접근법은 빠른 적용이 가능하지만 트리 쉐이킹 효과가 제한적일 수 있습니다. 모듈 구조 개선 접근법은 효과적인 트리 쉐이킹을 가능하게 하면서도 기존 코드와의 호환성을 유지할 수 있습니다. 서브패키지 접근법은 최적의 트리 쉐이킹 효과를 제공하지만 구현 복잡도가 높고 대규모 코드 변경이 필요합니다.

프로젝트의 상황에 맞는 접근 방식을 선택하고, 점진적인 마이그레이션 전략을 통해 트리 쉐이킹을 효과적으로 적용할 수 있습니다. 이를 통해 번들 크기를 줄이고, 애플리케이션의 성능을 향상시킬 수 있습니다.

