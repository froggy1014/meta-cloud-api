# 트리 쉐이킹 문제점 파악 및 개선 방안

## 현재 프로젝트 구조 요약

Meta Cloud API 프로젝트는 다음과 같은 구조로 구성되어 있습니다:

- `core`: 핵심 기능 (webhook, whatsapp)
- `features`: 다양한 기능 모듈 (messages, media, profile 등)
- `shared`: 공유 유틸리티 및 타입 (http, types, utils, config)

각 모듈은 barrel 파일(index.ts)을 통해 모든 내용을 export하고 있으며, 최상위 index.ts 파일에서 모든 모듈을 다시 export하는 구조입니다.

## 현재 barrel 파일 방식의 문제점

현재 프로젝트에서 사용 중인 barrel 파일 방식은 다음과 같은 문제점을 가지고 있습니다:

### 1. 트리 쉐이킹 비효율성

현재 방식에서는 `export *` 구문을 통해 모든 모듈의 내용을 재export하고 있습니다. 이는 다음과 같은 문제를 야기합니다:

- **모듈 간 의존성 추적 어려움**: 번들러가 실제로 사용되는 코드를 정확히 파악하기 어렵습니다.
- **불필요한 코드 포함**: 사용하지 않는 모듈이나 함수도 최종 번들에 포함될 가능성이 높습니다.
- **번들 크기 증가**: 결과적으로 최종 번들 크기가 필요 이상으로 커집니다.

예를 들어, 현재 구조에서는 다음과 같이 import합니다:

```typescript
import { MessagesApi } from 'meta-cloud-api';
```

이 경우, 번들러는 `MessagesApi`만 필요하더라도 다른 모든 API 클래스와 타입을 함께 번들링할 가능성이 높습니다.

### 2. 순환 참조 위험

barrel 파일을 통한 광범위한 export는 순환 참조(circular dependency)의 위험을 증가시킵니다:

- 모듈 A가 모듈 B를 참조하고, 모듈 B가 다시 모듈 A를 참조하는 상황이 발생할 수 있습니다.
- 이는 예측하기 어려운 런타임 오류나 초기화 문제를 야기할 수 있습니다.

### 3. 타입 정의 중복

현재 구조에서는 타입 정의가 여러 번 export되고 있습니다:

```typescript
// features/messages/types/index.ts
export * from './common';
export type { GeneralMessageBody, MessageRequestParams /* ... */ } from './common';
```

이러한 중복은 코드 유지보수를 어렵게 만들고, 타입 변경 시 여러 곳을 수정해야 하는 문제를 야기합니다.

## 트리 쉐이킹 개선 방안

트리 쉐이킹을 효과적으로 적용하기 위한 개선 방안은 다음과 같습니다:

### 1. 명시적 export 사용

`export *` 대신 명시적으로 필요한 항목만 export하는 방식으로 변경합니다:

```typescript
// 변경 전 (barrel 방식)
export * from './messages';
export * from './media';
// ...

// 변경 후 (명시적 export)
export { MessagesApi } from './messages';
export { MediaApi } from './media';
// ...
```

이렇게 하면 번들러가 사용되는 모듈을 정확히 파악하고 트리 쉐이킹을 효과적으로 수행할 수 있습니다.

### 2. 경로 별칭(Path Aliases) 사용

barrel 파일을 통한 import 대신 경로 별칭을 사용하여 직접 필요한 모듈을 import합니다:

```typescript
// tsconfig.json
{
  "compilerOptions": {
    "baseUrl": ".",
    "paths": {
      "@core/*": ["src/core/*"],
      "@features/*": ["src/features/*"],
      "@shared/*": ["src/shared/*"]
    }
  }
}
```

이를 통해 다음과 같이 직접적인 import가 가능합니다:

```typescript
// 변경 전
import { MessagesApi } from 'meta-cloud-api';

// 변경 후
import { MessagesApi } from '@features/messages';
```

### 3. 서브패키지 구조 도입

큰 프로젝트의 경우, 서브패키지 구조를 도입하여 각 기능을 독립적인 패키지로 분리할 수 있습니다:

```
meta-cloud-api/
├── packages/
│   ├── core/
│   ├── messages/
│   ├── media/
│   └── ...
└── package.json
```

이렇게 하면 사용자가 필요한 패키지만 선택적으로 import할 수 있습니다:

```typescript
import { WhatsApp } from '@meta-cloud-api/core';
import { MessagesApi } from '@meta-cloud-api/messages';
```

### 4. 사이드 이펙트 최소화

모듈에서 사이드 이펙트를 최소화하고, 필요한 경우 명시적으로 표시합니다:

```typescript
// package.json
{
  "sideEffects": false
}
```

또는 특정 파일에만 사이드 이펙트가 있는 경우:

```typescript
// package.json
{
  "sideEffects": ["*.css", "src/some-file.ts"]
}
```

### 5. 번들러 설정 최적화

tsup 설정을 더욱 최적화하여 트리 쉐이킹을 강화합니다:

```typescript
// tsup.config.ts
import { defineConfig } from 'tsup';

export default defineConfig({
  entry: {
    index: 'src/index.ts',
    core: 'src/core/index.ts',
    messages: 'src/features/messages/index.ts',
    media: 'src/features/media/index.ts',
    // 각 기능별 엔트리 포인트 추가
  },
  format: ['esm'],
  dts: true,
  sourcemap: true,
  clean: true,
  minify: true,
  splitting: true,
  treeshake: true,
  target: 'es2022',
  platform: 'node',
  external: ['node:*', 'crypto', 'fs', 'path', 'url', 'util'],
});
```

이렇게 각 기능별로 별도의 엔트리 포인트를 제공하면 사용자가 필요한 기능만 import할 수 있습니다.

## 결론

현재 barrel 파일을 통한 import 방식은 편리하지만 트리 쉐이킹 측면에서 비효율적입니다. 명시적 export, 경로 별칭, 서브패키지 구조 등의 방법을 통해 트리 쉐이킹을 효과적으로 적용할 수 있습니다. 다음 섹션에서는 이러한 개선 방안을 적용한 예시 코드를 제시하겠습니다.

